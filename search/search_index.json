{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Enchantrix","text":"<p>Enchantrix is a Go-based crypto library and miner application. This documentation provides information on how to use the various features of the Enchantrix library.</p>"},{"location":"#trix-file-format","title":"Trix File Format","text":"<p>The <code>.trix</code> file format is a generic and flexible binary container for storing an arbitrary data payload alongside structured metadata. For more information, see the Trix File Format page.</p>"},{"location":"#examples","title":"Examples","text":"<p>The following pages provide examples of how to use the Enchantrix library:</p> <ul> <li>Trix &amp; Sigil Chaining</li> <li>Hashing</li> <li>Checksums</li> <li>RSA</li> <li>Standalone Sigils</li> </ul>"},{"location":"checksums/","title":"Checksums","text":"<p>This example demonstrates how to use the <code>crypt</code> service to calculate checksums using various algorithms.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Snider/Enchantrix/pkg/crypt\"\n)\n\nfunc demoChecksums() {\n    fmt.Println(\"--- Checksum Demo ---\")\n    cryptService := crypt.NewService()\n\n    // Luhn\n    luhnPayloadGood := \"49927398716\"\n    luhnPayloadBad := \"49927398717\"\n    fmt.Printf(\"Luhn Checksum:\\n\")\n    fmt.Printf(\"  - Payload '%s' is valid: %v\\n\", luhnPayloadGood, cryptService.Luhn(luhnPayloadGood))\n    fmt.Printf(\"  - Payload '%s' is valid: %v\\n\", luhnPayloadBad, cryptService.Luhn(luhnPayloadBad))\n\n    // Fletcher\n    fletcherPayload := \"abcde\"\n    fmt.Printf(\"\\nFletcher Checksums (Payload: \\\"%s\\\"):\\n\", fletcherPayload)\n    fmt.Printf(\"  - Fletcher16: %d\\n\", cryptService.Fletcher16(fletcherPayload))\n    fmt.Printf(\"  - Fletcher32: %d\\n\", cryptService.Fletcher32(fletcherPayload))\n    fmt.Printf(\"  - Fletcher64: %d\\n\", cryptService.Fletcher64(fletcherPayload))\n    fmt.Println()\n}\n</code></pre>"},{"location":"hashing/","title":"Hashing","text":"<p>This example demonstrates how to use the <code>crypt</code> service to hash a payload using various algorithms.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Snider/Enchantrix/pkg/crypt\"\n)\n\nfunc demoHashing() {\n    fmt.Println(\"--- Hashing Demo ---\")\n    cryptService := crypt.NewService()\n    payload := \"Enchantrix\"\n\n    hashTypes := []crypt.HashType{\n        crypt.LTHN,\n        crypt.MD5,\n        crypt.SHA1,\n        crypt.SHA256,\n        crypt.SHA512,\n    }\n\n    fmt.Printf(\"Payload to hash: \\\"%s\\\"\\n\", payload)\n    for _, hashType := range hashTypes {\n        hash := cryptService.Hash(hashType, payload)\n        fmt.Printf(\"  - %-6s: %s\\n\", hashType, hash)\n    }\n    fmt.Println()\n}\n</code></pre>"},{"location":"rsa/","title":"RSA","text":"<p>This example demonstrates how to use the <code>crypt</code> service to generate an RSA key pair, encrypt a message, and then decrypt it.</p> <pre><code>package main\n\nimport (\n    \"encoding/base64\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/Snider/Enchantrix/pkg/crypt\"\n)\n\nfunc demoRSA() {\n    fmt.Println(\"--- RSA Demo ---\")\n    cryptService := crypt.NewService()\n\n    // 1. Generate RSA key pair\n    fmt.Println(\"Generating 2048-bit RSA key pair...\")\n    publicKey, privateKey, err := cryptService.GenerateRSAKeyPair(2048)\n    if err != nil {\n        log.Fatalf(\"Failed to generate RSA key pair: %v\", err)\n    }\n    fmt.Println(\"Key pair generated successfully.\")\n\n    // 2. Encrypt a message\n    message := []byte(\"This is a secret message for RSA.\")\n    fmt.Printf(\"\\nOriginal message: %s\\n\", message)\n    ciphertext, err := cryptService.EncryptRSA(publicKey, message, nil)\n    if err != nil {\n        log.Fatalf(\"Failed to encrypt with RSA: %v\", err)\n    }\n    fmt.Printf(\"Encrypted ciphertext (base64): %s\\n\", base64.StdEncoding.EncodeToString(ciphertext))\n\n    // 3. Decrypt the message\n    decrypted, err := cryptService.DecryptRSA(privateKey, ciphertext, nil)\n    if err != nil {\n        log.Fatalf(\"Failed to decrypt with RSA: %v\", err)\n    }\n    fmt.Printf(\"Decrypted message: %s\\n\", decrypted)\n\n    // 4. Verify\n    if string(message) == string(decrypted) {\n        fmt.Println(\"\\nSuccess! RSA decrypted message matches the original.\")\n    } else {\n        fmt.Println(\"\\nFailure! RSA decrypted message does not match the original.\")\n    }\n    fmt.Println()\n}\n</code></pre>"},{"location":"standalone_sigils/","title":"Standalone Sigils","text":"<p>This example demonstrates how to use sigils independently to transform data.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/Snider/Enchantrix/pkg/enchantrix\"\n)\n\nfunc demoSigils() {\n    fmt.Println(\"--- Standalone Sigil Demo ---\")\n    data := []byte(`{\"message\": \"hello world\"}`)\n    fmt.Printf(\"Original data: %s\\n\", data)\n\n    // A chain of sigils to apply\n    sigils := []string{\"gzip\", \"base64\"}\n    fmt.Printf(\"Applying sigil chain: %v\\n\", sigils)\n\n    var transformedData = data\n    for _, name := range sigils {\n        s, err := enchantrix.NewSigil(name)\n        if err != nil {\n            log.Fatalf(\"Failed to create sigil %s: %v\", name, err)\n        }\n        transformedData, err = s.In(transformedData)\n        if err != nil {\n            log.Fatalf(\"Failed to apply sigil %s 'In': %v\", name, err)\n        }\n        fmt.Printf(\" -&gt; After '%s': %s\\n\", name, transformedData)\n    }\n\n    fmt.Println(\"\\nReversing sigil chain...\")\n    // Reverse the transformations\n    for i := len(sigils) - 1; i &gt;= 0; i-- {\n        name := sigils[i]\n        s, err := enchantrix.NewSigil(name)\n        if err != nil {\n            log.Fatalf(\"Failed to create sigil %s: %v\", name, err)\n        }\n        transformedData, err = s.Out(transformedData)\n        if err != nil {\n            log.Fatalf(\"Failed to apply sigil %s 'Out': %v\", name, err)\n        }\n        fmt.Printf(\" -&gt; After '%s' Out: %s\\n\", name, transformedData)\n    }\n\n    if string(data) == string(transformedData) {\n        fmt.Println(\"Success! Data returned to original state.\")\n    } else {\n        fmt.Println(\"Failure! Data did not return to original state.\")\n    }\n    fmt.Println()\n}\n</code></pre>"},{"location":"trix_and_sigils/","title":"Trix &amp; Sigil Chaining","text":"<p>This example demonstrates how to use the Trix container with a chain of sigils to obfuscate and then encrypt a payload.</p> <pre><code>package main\n\nimport (\n    \"bytes\"\n    \"encoding/base64\"\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/Snider/Enchantrix/pkg/crypt\"\n    \"github.com/Snider/Enchantrix/pkg/crypt/std/chachapoly\"\n    \"github.com/Snider/Enchantrix/pkg/trix\"\n)\n\nfunc demoTrix() {\n    fmt.Println(\"--- Trix &amp; Sigil Chaining Demo ---\")\n\n    // 1. Original plaintext (JSON data) and encryption key\n    type Message struct {\n        Author string `json:\"author\"`\n        Time   int64  `json:\"time\"`\n        Body   string `json:\"body\"`\n    }\n    originalMessage := Message{Author: \"Jules\", Time: time.Now().Unix(), Body: \"This is a super secret message!\"}\n    plaintext, err := json.Marshal(originalMessage)\n    if err != nil {\n        log.Fatalf(\"Failed to marshal JSON: %v\", err)\n    }\n    key := make([]byte, 32) // In a real application, use a secure key\n    for i := range key {\n        key[i] = 1\n    }\n\n    fmt.Printf(\"Original Payload (JSON):\\n%s\\n\\n\", plaintext)\n\n    // 2. Create a Trix container with the plaintext and attach a chain of sigils\n    sigilChain := []string{\"json-indent\", \"gzip\", \"base64\", \"reverse\"}\n    trixContainer := &amp;trix.Trix{\n        Header:   map[string]interface{}{},\n        Payload:  plaintext,\n        InSigils: sigilChain,\n    }\n\n    // 3. Pack the Trix container to apply the sigil transformations\n    fmt.Println(\"Packing payload with sigils:\", sigilChain)\n    if err := trixContainer.Pack(); err != nil {\n        log.Fatalf(\"Failed to pack trix container: %v\", err)\n    }\n    fmt.Printf(\"Packed (obfuscated) payload is now non-human-readable bytes.\\n\\n\")\n\n    // 4. Encrypt the packed payload\n    ciphertext, err := chachapoly.Encrypt(trixContainer.Payload, key)\n    if err != nil {\n        log.Fatalf(\"Failed to encrypt: %v\", err)\n    }\n    trixContainer.Payload = ciphertext // Update the payload with the ciphertext\n\n    // 5. Add encryption metadata and checksum to the header\n    nonce := ciphertext[:24]\n    trixContainer.Header = map[string]interface{}{\n        \"content_type\":         \"application/json\",\n        \"encryption_algorithm\": \"chacha20poly1305\",\n        \"nonce\":                base64.StdEncoding.EncodeToString(nonce),\n        \"created_at\":           time.Now().UTC().Format(time.RFC3339),\n    }\n    trixContainer.ChecksumAlgo = crypt.SHA512\n    fmt.Printf(\"Checksum will be calculated with %s and added to the header.\\n\", trixContainer.ChecksumAlgo)\n\n    // 6. Encode the .trix container into its binary format\n    magicNumber := \"MyT1\"\n    encodedTrix, err := trix.Encode(trixContainer, magicNumber, nil)\n    if err != nil {\n        log.Fatalf(\"Failed to encode .trix container: %v\", err)\n    }\n    fmt.Println(\"Successfully created .trix container.\")\n\n    // --- DECODING ---\n    fmt.Println(\"--- DECODING ---\")\n\n    // 7. Decode the .trix container\n    decodedTrix, err := trix.Decode(encodedTrix, magicNumber, nil)\n    if err != nil {\n        log.Fatalf(\"Failed to decode .trix container: %v\", err)\n    }\n    fmt.Println(\"Successfully decoded .trix container. Checksum verified.\")\n    fmt.Printf(\"Decoded Header: %+v\\n\", decodedTrix.Header)\n\n    // 8. Decrypt the payload\n    decryptedPayload, err := chachapoly.Decrypt(decodedTrix.Payload, key)\n    if err != nil {\n        log.Fatalf(\"Failed to decrypt: %v\", err)\n    }\n    decodedTrix.Payload = decryptedPayload\n    fmt.Println(\"Payload decrypted.\")\n\n    // 9. Unpack the Trix container to reverse the sigil transformations\n    decodedTrix.InSigils = trixContainer.InSigils // Re-attach sigils for unpacking\n    fmt.Println(\"Unpacking payload by reversing sigils:\", decodedTrix.InSigils)\n    if err := decodedTrix.Unpack(); err != nil {\n        log.Fatalf(\"Failed to unpack trix container: %v\", err)\n    }\n    fmt.Printf(\"Unpacked (original) payload:\\n%s\\n\", decodedTrix.Payload)\n\n    // 10. Verify the result\n    // To properly verify, we need to compact the indented JSON before comparing\n    var compactedPayload bytes.Buffer\n    if err := json.Compact(&amp;compactedPayload, decodedTrix.Payload); err != nil {\n        log.Fatalf(\"Failed to compact final payload for verification: %v\", err)\n    }\n\n    if bytes.Equal(plaintext, compactedPayload.Bytes()) {\n        fmt.Println(\"\\nSuccess! The message was decrypted and unpacked correctly.\")\n    } else {\n        fmt.Println(\"\\nFailure! The final payload does not match the original.\")\n    }\n    fmt.Println()\n}\n</code></pre>"},{"location":"trix_format/","title":".trix File Format v2.0","text":"<p>The <code>.trix</code> file format is a generic and flexible binary container for storing an arbitrary data payload alongside structured metadata.</p>"},{"location":"trix_format/#structure","title":"Structure","text":"<p>The file is structured as follows:</p> Field Size (bytes) Description Magic Number 4 A constant value, <code>TRIX</code>, to identify the file as a <code>.trix</code> file. Version 1 The version of the <code>.trix</code> file format (currently <code>2</code>). Header Length 4 A 32-bit unsigned integer specifying the length of the JSON Header in bytes. This allows for flexible and extensible metadata. JSON Header <code>Header Length</code> A UTF-8 encoded JSON object containing metadata about the payload. Common keys include <code>content_type</code>, <code>encryption_algorithm</code>, <code>nonce</code>, <code>tag</code>, and <code>created_at</code>. Payload variable The raw binary data. This can be plaintext, ciphertext, or any other data. The interpretation of this data is guided by the metadata in the JSON Header."},{"location":"trix_format/#example-json-header","title":"Example JSON Header","text":"<p>Here is an example of what the JSON header might look like for a file encrypted with ChaCha20-Poly1305:</p> <pre><code>{\n  \"content_type\": \"application/octet-stream\",\n  \"encryption_algorithm\": \"chacha20poly1305\",\n  \"nonce\": \"AAECAwQFBgcICQoLDA0ODxAREhMUFRY=\",\n  \"created_at\": \"2025-10-30T12:00:00Z\"\n}\n</code></pre> <p>This decoupled design ensures that the <code>.trix</code> container is not tied to any specific encryption scheme, allowing for greater flexibility and future-proofing.</p>"}]}